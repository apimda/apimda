"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[903],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>y});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(n),c=r,y=d["".concat(s,".").concat(c)]||d[c]||m[c]||i;return n?a.createElement(y,o(o({ref:t},u),{},{components:n})):a.createElement(y,o({ref:t},u))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4205:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:2},o="Requests",l={unversionedId:"controllers/requests",id:"controllers/requests",title:"Requests",description:"Apimda validates and injects key elements of an HTTP request, such as query/path parameters, headers, cookies, and",source:"@site/docs/controllers/requests.md",sourceDirName:"controllers",slug:"/controllers/requests",permalink:"/apimda/docs/controllers/requests",draft:!1,editUrl:"https://github.com/joemays/apimda/tree/main/docs/docs/controllers/requests.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Routes",permalink:"/apimda/docs/controllers/routes"},next:{title:"Responses",permalink:"/apimda/docs/controllers/responses"}},s={},p=[{value:"@Path",id:"path",level:2},{value:"@Query",id:"query",level:2},{value:"@Header",id:"header",level:2},{value:"@Cookie",id:"cookie",level:2},{value:"@Body",id:"body",level:2},{value:"@Request",id:"request",level:2},{value:"Custom Type Validations",id:"custom-type-validations",level:2},{value:"Use type aliases or interfaces instead of classes",id:"use-type-aliases-or-interfaces-instead-of-classes",level:3},{value:"Apimda has limited support for generic types",id:"apimda-has-limited-support-for-generic-types",level:3},{value:"Avoid using union types (except optionals)",id:"avoid-using-union-types-except-optionals",level:3},{value:"Extend validation with JSDoc annotations",id:"extend-validation-with-jsdoc-annotations",level:3},{value:"Custom validation",id:"custom-validation",level:3}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"requests"},"Requests"),(0,r.kt)("p",null,"Apimda validates and injects key elements of an HTTP request, such as query/path parameters, headers, cookies, and\nrequest body into your handler methods. This allows you to focus on writing business logic, and provides a single source\nof truth for your API deployment, implementation, and documentation. It does so using\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/decorators.html#parameter-decorators"},"parameter decorators")," described\nbelow."),(0,r.kt)("h2",{id:"path"},"@Path"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@Path")," injects a path parameter into your handler method."),(0,r.kt)("p",null,"It takes an optional argument specifying the path parameter's name, though this isn't usually needed as it defaults to\nthe assigned variable's name."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Controller('/orders')\nclass OrderController {\n  @Get('/{orderId}')\n  async getById(@Path() orderId: number): Promise<Order> {\n    // ...\n  }\n}\n")),(0,r.kt)("p",null,"For example, in the request above:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GET /orders/1256")," would have ",(0,r.kt)("inlineCode",{parentName:"li"},"orderId")," of ",(0,r.kt)("inlineCode",{parentName:"li"},"1256"))),(0,r.kt)("p",null,"Note:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"All declared ",(0,r.kt)("inlineCode",{parentName:"li"},"@Path()")," parameters ",(0,r.kt)("em",{parentName:"li"},"must be")," present in the route."),(0,r.kt)("li",{parentName:"ul"},"Every parameter declared in the route ",(0,r.kt)("em",{parentName:"li"},"must have")," a ",(0,r.kt)("inlineCode",{parentName:"li"},"@Path()")," parameter assigned."),(0,r.kt)("li",{parentName:"ul"},"Optional path variables are ",(0,r.kt)("em",{parentName:"li"},"not allowed"),".")),(0,r.kt)("h2",{id:"query"},"@Query"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@Query(queryParamName)")," injects a query string parameter into your handler method."),(0,r.kt)("p",null,"It takes an optional argument specifying the query string parameter's name, though this isn't usually needed as it\ndefaults to the assigned variable's name."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Controller('/orders')\nclass OrderController {\n  @Get()\n  async findOrders(@Query() orderType?: string): Promise<Order> {\n    // return all orders, optionally filtered by order type\n  }\n}\n")),(0,r.kt)("p",null,"For example, in the request above:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GET /orders?orderType=PARTNER")," would have ",(0,r.kt)("inlineCode",{parentName:"li"},"orderType")," of ",(0,r.kt)("inlineCode",{parentName:"li"},'"PARTNER"'),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GET /orders")," would have ",(0,r.kt)("inlineCode",{parentName:"li"},"orderType")," as ",(0,r.kt)("inlineCode",{parentName:"li"},"undefined"))),(0,r.kt)("p",null,"Note:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can optionally specify a different variable name from the query parameter."),(0,r.kt)("li",{parentName:"ul"},"Query parameters may be optional.")),(0,r.kt)("h2",{id:"header"},"@Header"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@Header")," injects a header value into your handler method. It takes a single required parameter specifying the header's\nname."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Controller()\nclass SampleController {\n  @Get('/isWebKit')\n  async isWebKit(@Header('User-Agent') userAgent?: string): Promise<boolean> {\n    // return true if webkit-based browser\n  }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Header names must be specified in ",(0,r.kt)("inlineCode",{parentName:"li"},"@Header()")," decorator."),(0,r.kt)("li",{parentName:"ul"},"Injected header values may be optional.")),(0,r.kt)("h2",{id:"cookie"},"@Cookie"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@Cookie")," injects a cookie value into your handler method. It takes a single required parameter specifying the cookie's\nname."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Controller()\nclass SampleController {\n  @Get('/sample')\n  async sample(@Cookie('CookieName') cookie?: string): Promise<boolean> {\n    // ...\n  }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Cookie names must be specified in ",(0,r.kt)("inlineCode",{parentName:"li"},"@Cookie()")," decorator."),(0,r.kt)("li",{parentName:"ul"},"Injected cookie values may be optional.")),(0,r.kt)("h2",{id:"body"},"@Body"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@Body")," injects the request body into your handler method. It takes a single optional parameter, indicating the body's\nMIME type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Controller('/user')\nclass UserController {\n  @Post()\n  async createUser(@Body() user: User): Promise<User> {\n    // create and return user\n  }\n\n  @Put('/{userId}')\n  async updateUser(@Body() user: User): Promise<User> {\n    // update and return user\n  }\n\n  @Put('/{userId}/avatar')\n  async setAvatar(@Path() userId: string, @Body('image/*') avatar: Buffer) {\n    // upload/replace binary avatar image for user\n  }\n}\n")),(0,r.kt)("p",null,"How the body is injected depends upon the parameter type:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"For custom types (default), apimda will deserialize the body as JSON and validate it against the type definition (\nsee ",(0,r.kt)("inlineCode",{parentName:"li"},"createUser")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"updateUser")," above)."),(0,r.kt)("li",{parentName:"ul"},"For binary data, apimda will ensure that the body is binary (i.e. the isBase64Encoded property of the API Gateway\nevent is ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),"), and decode the data automatically into a ",(0,r.kt)("inlineCode",{parentName:"li"},"Buffer")," (see ",(0,r.kt)("inlineCode",{parentName:"li"},"setAvatar")," above)."),(0,r.kt)("li",{parentName:"ul"},"For text data, apimda will inject the body as a ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," directly from API Gateway event.")),(0,r.kt)("p",null,"Note:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"There are limitations on custom types / JSON deserialization. See below."),(0,r.kt)("li",{parentName:"ul"},"You can only have one ",(0,r.kt)("inlineCode",{parentName:"li"},"@Body")," parameter per handler method.")),(0,r.kt)("h2",{id:"request"},"@Request"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@Request")," injects the raw value of the API Gateway event into your handler method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@Controller()\nclass SampleController {\n  @Get('/sample')\n  async sample(@Request() event: APIGatewayProxyEventV2) {\n    // ...\n  }\n}\n")),(0,r.kt)("p",null,"Note:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The specific type of AWS API Gateway event will depend on how you've configured your route. For example, you can\nuse ",(0,r.kt)("inlineCode",{parentName:"li"},"APIGatewayProxyEventV2WithJWTAuthorizer")," if you've configured an appropriate authorizer. Apimda leaves this\ncompletely up to you. Be careful and select the base event type ",(0,r.kt)("inlineCode",{parentName:"li"},"APIGatewayProxyEventV2")," unless you're certain you\nneed the additional data from other event types AND you've properly configured your route/authorizer."),(0,r.kt)("li",{parentName:"ul"},"You can only have one ",(0,r.kt)("inlineCode",{parentName:"li"},"@Request")," parameter per handler method.")),(0,r.kt)("h2",{id:"custom-type-validations"},"Custom Type Validations"),(0,r.kt)("p",null,"Apimda validates custom input types using JSON schemas. How this currently works:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Apimda ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/vega/ts-json-schema-generator"},"generates")," JSON schemas for all non-primitive types at\ndeploy time."),(0,r.kt)("li",{parentName:"ol"},"Non-primitive types are ",(0,r.kt)("a",{parentName:"li",href:"https://ajv.js.org"},"validated")," against their schemas using at runtime."),(0,r.kt)("li",{parentName:"ol"},"If schema validation fails, a ",(0,r.kt)("inlineCode",{parentName:"li"},"400: Bad Request")," response is sent to the client.")),(0,r.kt)("p",null,"Apimda relies upon the types you declare (or are inferred by the typescript compiler), some custom logic, and some third\nparty libraries (see above) for JSON deserialization and validation. This means that there are limitations."),(0,r.kt)("h3",{id:"use-type-aliases-or-interfaces-instead-of-classes"},"Use type aliases or interfaces instead of classes"),(0,r.kt)("p",null,"Apimda cannot deserialize JSON into typescript classes. Use interfaces and type aliases instead."),(0,r.kt)("h3",{id:"apimda-has-limited-support-for-generic-types"},"Apimda has limited support for generic types"),(0,r.kt)("p",null,"Apimda can only currently deserialize arrays, i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"Array<T>")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"T[]"),". It cannot deserialize other generic types. If\nyou need to use a generic of a specific type, however, you can use a type alias. For example, it's common to\nuse ",(0,r.kt)("inlineCode",{parentName:"p"},"Partial<T>")," to make the input to a ",(0,r.kt)("inlineCode",{parentName:"p"},"PATCH")," request optional:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface User {\n  email: string;\n  firstName: string;\n  lastName: string;\n  phone?: string;\n}\n\ntype UserPatch = Partial<User>;\n\n@Controller('/users')\nclass UserController {\n  @Post()\n  async createUser(@Body() user: User): Promise<User> {\n    // create and return user\n  }\n\n  @Patch('/{userId}')\n  async patchUser(@Path userId: string, @Body() user: UserPatch): Promise<User> {\n    // partially update and return user\n  }\n}\n")),(0,r.kt)("p",null,"In the example above, we use the standard ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," type for ",(0,r.kt)("inlineCode",{parentName:"p"},"POST")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"PUT"),", but the partial alias ",(0,r.kt)("inlineCode",{parentName:"p"},"UserPatch"),"\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"PATCH")," to work around the generic type limitations on request parameters. You can use type aliases to work around\nsome generic type limitations in apimda."),(0,r.kt)("p",null,"Another common use case is to return a page of objects from a controller method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Page<T> {\n  results: T[];\n  offset: number;\n  count: number;\n}\n\ntype UserPage = Page<User>;\n\n@Controller('/users')\nclass UserController {\n  @Get()\n  async getPageOfUsers(@Query() limit: number, @Query offset: number): Promise<UserPage> {\n    // return page of users\n  }\n}\n")),(0,r.kt)("h3",{id:"avoid-using-union-types-except-optionals"},"Avoid using union types (except optionals)"),(0,r.kt)("p",null,"Apimda cannot decode union types as input parameters. You can use type aliases to workaround this similarly as with\ngenerics (see above)."),(0,r.kt)("p",null,"(The one exception is optional function arguments, which are similar to union types but not exactly the same.)"),(0,r.kt)("h3",{id:"extend-validation-with-jsdoc-annotations"},"Extend validation with JSDoc annotations"),(0,r.kt)("p",null,"You can use ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/vega/ts-json-schema-generator/tree/next/src/AnnotationsReader"},"JSDoc annotations")," to\nextend JSON schema validation."),(0,r.kt)("p",null,"You can combine them with type aliases to validate strings against patterns or use pre-defined JSON schema formats."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * UUID v4\n * See [RFC 4112](https://tools.ietf.org/html/rfc4122)\n * @format uuid\n * @examples [\"52907745-7672-470e-a803-a2f8feb52944\"]\n */\nexport type UUID = string;\n\n@Controller('/pets')\nclass PetController {\n  @Get('/{petId}')\n  async getById(@Path() petId: UUID): Promise<Pet> {\n    // ...\n  }\n}\n")),(0,r.kt)("p",null,"In the example above:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GET /pets/1f31905f-5c30-419a-9aa6-a65192af5426")," would invoke ",(0,r.kt)("inlineCode",{parentName:"li"},"getById")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"petId"),"\nof ",(0,r.kt)("inlineCode",{parentName:"li"},"1f31905f-5c30-419a-9aa6-a65192af5426")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GET /pets/1677")," would return ",(0,r.kt)("inlineCode",{parentName:"li"},"400: Bad Request")," to the client without ever invoking ",(0,r.kt)("inlineCode",{parentName:"li"},"getById"))),(0,r.kt)("h3",{id:"custom-validation"},"Custom validation"),(0,r.kt)("p",null,"In cases where out-of-the-box support is not sufficient, you can always declare your arguments as ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," or\nuse ",(0,r.kt)("inlineCode",{parentName:"p"},"@Request")," to perform your own custom validation. If there's a feature that you think should be built in, we\nwelcome ",(0,r.kt)("a",{parentName:"p",href:"/docs/contributions"},"contributions"),"!"))}d.isMDXComponent=!0}}]);